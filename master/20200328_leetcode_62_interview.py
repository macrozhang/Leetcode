# 面试题62. 圆圈中最后剩下的数字


class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        i, a = 0, list(range(n))
        while len(a) > 1:
            i = (i + m - 1) % len(a)
            a.pop(i)
        return a[0]


# 这个游戏里叫击鼓传花，西方也有叫热土豆。可通过严格的数学推导直接计算得出。但我们用程序来全真模拟才更真实。
# 1.生成一个0——n-1的列表，初始索引i=0
# 2.传递m次，意味着从i开始偏移m得到新索引i=i+m-1，考虑m可能大于当前列表长度，所以要对列表长度求模余
# 3.从列表中pop出一个值后，实际上下一个值的索引位置未改变（因为后边的值都前移了一位），所以仍然是用i=i+m-1计算新的索引，当然也要用新的列表长度求模
# 4.直至列表长度为1，返回最后剩下的数字。
#
# 因为列表中pop(i)是平均O(n)复杂度，所以总的时间复杂度是O(n2)

